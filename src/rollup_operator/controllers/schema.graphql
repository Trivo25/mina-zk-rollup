type Commitment {
  pendingDepositsCommitment: String
  accountDbCommitment: String
}

type State {
  committed: Commitment
  current: Commitment
}

type GlobalState {
  pendingDeposits: [String]
  state: State
}

type Query {
  getGlobalState: GlobalState
}

input ProofOrSignature {
  proof: String
  signature: String
}

input AuthRequired {
  a: String
}

input Permissions {
  editState: AuthRequired
  send: AuthRequired
  receive: AuthRequired
  setDelegate: AuthRequired
  setPermissions: AuthRequired
  setVerificationKey: AuthRequired
  setZkappUri: AuthRequired
  editSequenceState: AuthRequired
  setTokenSymbol: AuthRequired
  incrementNonce: AuthRequired
  setVotingFor: AuthRequired
}

input TimingInput {
  initialMinimumBalance: String
  cliffTime: String
  cliffAmount: String
  vestingPeriod: String
  vestingIncrement: String
}

input VerificationKey {
  data: String
  hash: String
}

input Update {
  appState: [String]
  delegate: String
  verificationKey: VerificationKey
  permissions: Permissions
  zkappUri: String
  tokenSymbol: String
  timing: TimingInput
  votingFor: String
}

input BalanceChange {
  magnitude: Int!
  sgn: String!
}

input LowerUpper {
  lower: String!
  upper: String!
}

input EpochLedger {
  hash: String
  totalCurrency: LowerUpper
}

input EpochData {
  ledger: EpochLedger!
  seed: String
  startCheckpoint: String
  lockCheckpoint: String
  epochLength: LowerUpper
}

input NetworkPreconditionInput {
  snarkedLedgerHash: String
  timestamp: LowerUpper
  blockchainLength: LowerUpper
  minWindowDensity: LowerUpper
  totalCurrency: LowerUpper
  globalSlotSinceHardFork: LowerUpper
  globalSlotSinceGenesis: LowerUpper
  stakingEpochData: EpochData!
  nextEpochData: EpochData!
}

input AccountPreconditionInput {
  balance: LowerUpper
  nonce: LowerUpper
  receiptChainHash: String
  delegate: String
  state: [String]
  sequenceState: String
  provedState: Boolean
  isNew: Boolean
}

input Preconditions {
  network: NetworkPreconditionInput
  account: AccountPreconditionInput
}

input Body {
  publicKey: String!
  tokenId: String!
  update: Update!
  balanceChange: BalanceChange!
  incrementNonce: Boolean!
  events: [[String!]!]!
  sequenceEvents: [[String!]!]!
  callData: String!
  callDepth: Int!
  preconditions: Preconditions!
  useFullCommitment: Boolean!
  caller: String!
  authorizationKind: String!
}

input AccountUpdate {
  body: Body!
  authorization: ProofOrSignature!
}

input FeePayerBody {
  publicKey: String!
  fee: String!
  validUntil: Int
  nonce: String!
}

input FeePayer {
  body: FeePayerBody!
  authorization: String!
}

input ZkappCommandInput {
  feePayer: FeePayer!
  accountUpdates: [AccountUpdate!]!
  memo: String!
}

type Mutation {
  sendZkapp(input: ZkappCommandInput!): String
}
