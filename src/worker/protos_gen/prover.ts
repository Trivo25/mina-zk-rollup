// @generated by protobuf-ts 2.8.0 with parameter server_grpc1,client_grpc1
// @generated from protobuf file "prover.proto" (syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
// === DATA TYPES ===

/**
 * @generated from protobuf message VerifyRequest
 */
export interface VerifyRequest {
    /**
     * @generated from protobuf field: string challenge = 1;
     */
    challenge: string;
    /**
     * @generated from protobuf field: string signature = 2;
     */
    signature: string;
    /**
     * @generated from protobuf field: string publicKey = 3;
     */
    publicKey: string;
}
/**
 * @generated from protobuf message VerifyResponse
 */
export interface VerifyResponse {
    /**
     * @generated from protobuf field: bool isValid = 1;
     */
    isValid: boolean;
}
/**
 * @generated from protobuf message ChallengeRequest
 */
export interface ChallengeRequest {
    /**
     * @generated from protobuf field: string publicKey = 1;
     */
    publicKey: string;
    /**
     * @generated from protobuf field: string keyType = 2;
     */
    keyType: string;
}
/**
 * @generated from protobuf message ChallengeResponse
 */
export interface ChallengeResponse {
    /**
     * @generated from protobuf field: string challenge = 1;
     */
    challenge: string;
}
/**
 * echo request and response
 *
 * @generated from protobuf message EchoRequest
 */
export interface EchoRequest {
    /**
     * @generated from protobuf field: string echo = 1;
     */
    echo: string;
}
/**
 * @generated from protobuf message EchoResponse
 */
export interface EchoResponse {
    /**
     * @generated from protobuf field: string echo = 1;
     */
    echo: string;
}
/**
 * @generated from protobuf message ProofRequest
 */
export interface ProofRequest {
    /**
     * @generated from protobuf field: TransactionBatch batch = 1;
     */
    batch?: TransactionBatch;
}
/**
 * @generated from protobuf message ProofResponse
 */
export interface ProofResponse {
    /**
     * @generated from protobuf field: StateTransitionProof proof = 1;
     */
    proof?: StateTransitionProof;
}
/**
 * @generated from protobuf message StateTransition
 */
export interface StateTransition {
    /**
     * @generated from protobuf field: string accountRoot = 1;
     */
    accountRoot: string;
    /**
     * @generated from protobuf field: string depositRoot = 2;
     */
    depositRoot: string;
}
/**
 * @generated from protobuf message TransactionBatch
 */
export interface TransactionBatch {
    /**
     * @generated from protobuf field: StateTransition before = 1;
     */
    before?: StateTransition;
    /**
     * @generated from protobuf field: StateTransition after = 2;
     */
    after?: StateTransition;
    /**
     * @generated from protobuf field: repeated Transaction txns = 3;
     */
    txns: Transaction[];
}
/**
 * @generated from protobuf message Transaction
 */
export interface Transaction {
    /**
     * @generated from protobuf field: string amount = 1;
     */
    amount: string;
    /**
     * @generated from protobuf field: string nonce = 2;
     */
    nonce: string;
    /**
     * @generated from protobuf field: RollupAccount sender = 3;
     */
    sender?: RollupAccount;
    /**
     * @generated from protobuf field: RollupAccount receiver = 4;
     */
    receiver?: RollupAccount;
    /**
     * @generated from protobuf field: string tokenId = 5;
     */
    tokenId: string;
    /**
     * @generated from protobuf field: string signature = 6;
     */
    signature: string;
    /**
     * @generated from protobuf field: string to = 7;
     */
    to: string;
    /**
     * @generated from protobuf field: string from = 8;
     */
    from: string;
}
/**
 * @generated from protobuf message RollupAccount
 */
export interface RollupAccount {
    /**
     * @generated from protobuf field: string balance = 1;
     */
    balance: string;
    /**
     * @generated from protobuf field: string nonce = 2;
     */
    nonce: string;
    /**
     * @generated from protobuf field: string publicKey = 3;
     */
    publicKey: string;
    /**
     * @generated from protobuf field: MerkleProof merkleProof = 4;
     */
    merkleProof?: MerkleProof;
}
/**
 * @generated from protobuf message MerkleProof
 */
export interface MerkleProof {
    /**
     * @generated from protobuf field: repeated MerkleProof.MerkleProofElement elements = 1;
     */
    elements: MerkleProof_MerkleProofElement[];
}
/**
 * @generated from protobuf message MerkleProof.MerkleProofElement
 */
export interface MerkleProof_MerkleProofElement {
    /**
     * @generated from protobuf field: bool isLeft = 1;
     */
    isLeft: boolean;
    /**
     * @generated from protobuf field: string sibling = 2;
     */
    sibling: string;
}
/**
 * @generated from protobuf message StateTransitionProof
 */
export interface StateTransitionProof {
    /**
     * @generated from protobuf field: StateTransition before = 1;
     */
    before?: StateTransition;
    /**
     * @generated from protobuf field: StateTransition after = 2;
     */
    after?: StateTransition;
    /**
     * @generated from protobuf field: string proof = 3;
     */
    proof: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class VerifyRequest$Type extends MessageType<VerifyRequest> {
    constructor() {
        super("VerifyRequest", [
            { no: 1, name: "challenge", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "signature", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "publicKey", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<VerifyRequest>): VerifyRequest {
        const message = { challenge: "", signature: "", publicKey: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<VerifyRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VerifyRequest): VerifyRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string challenge */ 1:
                    message.challenge = reader.string();
                    break;
                case /* string signature */ 2:
                    message.signature = reader.string();
                    break;
                case /* string publicKey */ 3:
                    message.publicKey = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VerifyRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string challenge = 1; */
        if (message.challenge !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.challenge);
        /* string signature = 2; */
        if (message.signature !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.signature);
        /* string publicKey = 3; */
        if (message.publicKey !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.publicKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message VerifyRequest
 */
export const VerifyRequest = new VerifyRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VerifyResponse$Type extends MessageType<VerifyResponse> {
    constructor() {
        super("VerifyResponse", [
            { no: 1, name: "isValid", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<VerifyResponse>): VerifyResponse {
        const message = { isValid: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<VerifyResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VerifyResponse): VerifyResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool isValid */ 1:
                    message.isValid = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VerifyResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool isValid = 1; */
        if (message.isValid !== false)
            writer.tag(1, WireType.Varint).bool(message.isValid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message VerifyResponse
 */
export const VerifyResponse = new VerifyResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChallengeRequest$Type extends MessageType<ChallengeRequest> {
    constructor() {
        super("ChallengeRequest", [
            { no: 1, name: "publicKey", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "keyType", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ChallengeRequest>): ChallengeRequest {
        const message = { publicKey: "", keyType: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChallengeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChallengeRequest): ChallengeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string publicKey */ 1:
                    message.publicKey = reader.string();
                    break;
                case /* string keyType */ 2:
                    message.keyType = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChallengeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string publicKey = 1; */
        if (message.publicKey !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.publicKey);
        /* string keyType = 2; */
        if (message.keyType !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.keyType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ChallengeRequest
 */
export const ChallengeRequest = new ChallengeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChallengeResponse$Type extends MessageType<ChallengeResponse> {
    constructor() {
        super("ChallengeResponse", [
            { no: 1, name: "challenge", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ChallengeResponse>): ChallengeResponse {
        const message = { challenge: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChallengeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChallengeResponse): ChallengeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string challenge */ 1:
                    message.challenge = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChallengeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string challenge = 1; */
        if (message.challenge !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.challenge);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ChallengeResponse
 */
export const ChallengeResponse = new ChallengeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EchoRequest$Type extends MessageType<EchoRequest> {
    constructor() {
        super("EchoRequest", [
            { no: 1, name: "echo", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EchoRequest>): EchoRequest {
        const message = { echo: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EchoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EchoRequest): EchoRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string echo */ 1:
                    message.echo = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EchoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string echo = 1; */
        if (message.echo !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.echo);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EchoRequest
 */
export const EchoRequest = new EchoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EchoResponse$Type extends MessageType<EchoResponse> {
    constructor() {
        super("EchoResponse", [
            { no: 1, name: "echo", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EchoResponse>): EchoResponse {
        const message = { echo: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EchoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EchoResponse): EchoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string echo */ 1:
                    message.echo = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EchoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string echo = 1; */
        if (message.echo !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.echo);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EchoResponse
 */
export const EchoResponse = new EchoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProofRequest$Type extends MessageType<ProofRequest> {
    constructor() {
        super("ProofRequest", [
            { no: 1, name: "batch", kind: "message", T: () => TransactionBatch }
        ]);
    }
    create(value?: PartialMessage<ProofRequest>): ProofRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ProofRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProofRequest): ProofRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* TransactionBatch batch */ 1:
                    message.batch = TransactionBatch.internalBinaryRead(reader, reader.uint32(), options, message.batch);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProofRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* TransactionBatch batch = 1; */
        if (message.batch)
            TransactionBatch.internalBinaryWrite(message.batch, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ProofRequest
 */
export const ProofRequest = new ProofRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProofResponse$Type extends MessageType<ProofResponse> {
    constructor() {
        super("ProofResponse", [
            { no: 1, name: "proof", kind: "message", T: () => StateTransitionProof }
        ]);
    }
    create(value?: PartialMessage<ProofResponse>): ProofResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ProofResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProofResponse): ProofResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* StateTransitionProof proof */ 1:
                    message.proof = StateTransitionProof.internalBinaryRead(reader, reader.uint32(), options, message.proof);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProofResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* StateTransitionProof proof = 1; */
        if (message.proof)
            StateTransitionProof.internalBinaryWrite(message.proof, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ProofResponse
 */
export const ProofResponse = new ProofResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StateTransition$Type extends MessageType<StateTransition> {
    constructor() {
        super("StateTransition", [
            { no: 1, name: "accountRoot", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "depositRoot", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StateTransition>): StateTransition {
        const message = { accountRoot: "", depositRoot: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StateTransition>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StateTransition): StateTransition {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string accountRoot */ 1:
                    message.accountRoot = reader.string();
                    break;
                case /* string depositRoot */ 2:
                    message.depositRoot = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StateTransition, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string accountRoot = 1; */
        if (message.accountRoot !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accountRoot);
        /* string depositRoot = 2; */
        if (message.depositRoot !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.depositRoot);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StateTransition
 */
export const StateTransition = new StateTransition$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TransactionBatch$Type extends MessageType<TransactionBatch> {
    constructor() {
        super("TransactionBatch", [
            { no: 1, name: "before", kind: "message", T: () => StateTransition },
            { no: 2, name: "after", kind: "message", T: () => StateTransition },
            { no: 3, name: "txns", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Transaction }
        ]);
    }
    create(value?: PartialMessage<TransactionBatch>): TransactionBatch {
        const message = { txns: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TransactionBatch>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TransactionBatch): TransactionBatch {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* StateTransition before */ 1:
                    message.before = StateTransition.internalBinaryRead(reader, reader.uint32(), options, message.before);
                    break;
                case /* StateTransition after */ 2:
                    message.after = StateTransition.internalBinaryRead(reader, reader.uint32(), options, message.after);
                    break;
                case /* repeated Transaction txns */ 3:
                    message.txns.push(Transaction.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TransactionBatch, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* StateTransition before = 1; */
        if (message.before)
            StateTransition.internalBinaryWrite(message.before, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* StateTransition after = 2; */
        if (message.after)
            StateTransition.internalBinaryWrite(message.after, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated Transaction txns = 3; */
        for (let i = 0; i < message.txns.length; i++)
            Transaction.internalBinaryWrite(message.txns[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TransactionBatch
 */
export const TransactionBatch = new TransactionBatch$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Transaction$Type extends MessageType<Transaction> {
    constructor() {
        super("Transaction", [
            { no: 1, name: "amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "nonce", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "sender", kind: "message", T: () => RollupAccount },
            { no: 4, name: "receiver", kind: "message", T: () => RollupAccount },
            { no: 5, name: "tokenId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "signature", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "to", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "from", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Transaction>): Transaction {
        const message = { amount: "", nonce: "", tokenId: "", signature: "", to: "", from: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Transaction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Transaction): Transaction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string amount */ 1:
                    message.amount = reader.string();
                    break;
                case /* string nonce */ 2:
                    message.nonce = reader.string();
                    break;
                case /* RollupAccount sender */ 3:
                    message.sender = RollupAccount.internalBinaryRead(reader, reader.uint32(), options, message.sender);
                    break;
                case /* RollupAccount receiver */ 4:
                    message.receiver = RollupAccount.internalBinaryRead(reader, reader.uint32(), options, message.receiver);
                    break;
                case /* string tokenId */ 5:
                    message.tokenId = reader.string();
                    break;
                case /* string signature */ 6:
                    message.signature = reader.string();
                    break;
                case /* string to */ 7:
                    message.to = reader.string();
                    break;
                case /* string from */ 8:
                    message.from = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Transaction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string amount = 1; */
        if (message.amount !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.amount);
        /* string nonce = 2; */
        if (message.nonce !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.nonce);
        /* RollupAccount sender = 3; */
        if (message.sender)
            RollupAccount.internalBinaryWrite(message.sender, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* RollupAccount receiver = 4; */
        if (message.receiver)
            RollupAccount.internalBinaryWrite(message.receiver, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string tokenId = 5; */
        if (message.tokenId !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.tokenId);
        /* string signature = 6; */
        if (message.signature !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.signature);
        /* string to = 7; */
        if (message.to !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.to);
        /* string from = 8; */
        if (message.from !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.from);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Transaction
 */
export const Transaction = new Transaction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RollupAccount$Type extends MessageType<RollupAccount> {
    constructor() {
        super("RollupAccount", [
            { no: 1, name: "balance", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "nonce", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "publicKey", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "merkleProof", kind: "message", T: () => MerkleProof }
        ]);
    }
    create(value?: PartialMessage<RollupAccount>): RollupAccount {
        const message = { balance: "", nonce: "", publicKey: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RollupAccount>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RollupAccount): RollupAccount {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string balance */ 1:
                    message.balance = reader.string();
                    break;
                case /* string nonce */ 2:
                    message.nonce = reader.string();
                    break;
                case /* string publicKey */ 3:
                    message.publicKey = reader.string();
                    break;
                case /* MerkleProof merkleProof */ 4:
                    message.merkleProof = MerkleProof.internalBinaryRead(reader, reader.uint32(), options, message.merkleProof);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RollupAccount, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string balance = 1; */
        if (message.balance !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.balance);
        /* string nonce = 2; */
        if (message.nonce !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.nonce);
        /* string publicKey = 3; */
        if (message.publicKey !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.publicKey);
        /* MerkleProof merkleProof = 4; */
        if (message.merkleProof)
            MerkleProof.internalBinaryWrite(message.merkleProof, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message RollupAccount
 */
export const RollupAccount = new RollupAccount$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MerkleProof$Type extends MessageType<MerkleProof> {
    constructor() {
        super("MerkleProof", [
            { no: 1, name: "elements", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MerkleProof_MerkleProofElement }
        ]);
    }
    create(value?: PartialMessage<MerkleProof>): MerkleProof {
        const message = { elements: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MerkleProof>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MerkleProof): MerkleProof {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated MerkleProof.MerkleProofElement elements */ 1:
                    message.elements.push(MerkleProof_MerkleProofElement.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MerkleProof, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated MerkleProof.MerkleProofElement elements = 1; */
        for (let i = 0; i < message.elements.length; i++)
            MerkleProof_MerkleProofElement.internalBinaryWrite(message.elements[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MerkleProof
 */
export const MerkleProof = new MerkleProof$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MerkleProof_MerkleProofElement$Type extends MessageType<MerkleProof_MerkleProofElement> {
    constructor() {
        super("MerkleProof.MerkleProofElement", [
            { no: 1, name: "isLeft", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "sibling", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MerkleProof_MerkleProofElement>): MerkleProof_MerkleProofElement {
        const message = { isLeft: false, sibling: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MerkleProof_MerkleProofElement>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MerkleProof_MerkleProofElement): MerkleProof_MerkleProofElement {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool isLeft */ 1:
                    message.isLeft = reader.bool();
                    break;
                case /* string sibling */ 2:
                    message.sibling = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MerkleProof_MerkleProofElement, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool isLeft = 1; */
        if (message.isLeft !== false)
            writer.tag(1, WireType.Varint).bool(message.isLeft);
        /* string sibling = 2; */
        if (message.sibling !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.sibling);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MerkleProof.MerkleProofElement
 */
export const MerkleProof_MerkleProofElement = new MerkleProof_MerkleProofElement$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StateTransitionProof$Type extends MessageType<StateTransitionProof> {
    constructor() {
        super("StateTransitionProof", [
            { no: 1, name: "before", kind: "message", T: () => StateTransition },
            { no: 2, name: "after", kind: "message", T: () => StateTransition },
            { no: 3, name: "proof", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StateTransitionProof>): StateTransitionProof {
        const message = { proof: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StateTransitionProof>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StateTransitionProof): StateTransitionProof {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* StateTransition before */ 1:
                    message.before = StateTransition.internalBinaryRead(reader, reader.uint32(), options, message.before);
                    break;
                case /* StateTransition after */ 2:
                    message.after = StateTransition.internalBinaryRead(reader, reader.uint32(), options, message.after);
                    break;
                case /* string proof */ 3:
                    message.proof = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StateTransitionProof, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* StateTransition before = 1; */
        if (message.before)
            StateTransition.internalBinaryWrite(message.before, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* StateTransition after = 2; */
        if (message.after)
            StateTransition.internalBinaryWrite(message.after, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string proof = 3; */
        if (message.proof !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.proof);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StateTransitionProof
 */
export const StateTransitionProof = new StateTransitionProof$Type();
/**
 * @generated ServiceType for protobuf service ProverService
 */
export const ProverService = new ServiceType("ProverService", [
    { name: "Echo", options: {}, I: EchoRequest, O: EchoResponse },
    { name: "RequestChallenge", options: {}, I: ChallengeRequest, O: ChallengeResponse },
    { name: "Verify", options: {}, I: VerifyRequest, O: VerifyResponse },
    { name: "ProveBatch", options: {}, I: ProofRequest, O: ProofRequest }
]);
